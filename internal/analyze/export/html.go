package export

import (
	"fmt"
	"html"
	"sort"
	"strings"
	"time"

	"github.com/rand/pedantic-raven/internal/analyze"
	"github.com/rand/pedantic-raven/internal/editor/semantic"
)

// ExportHTML generates a responsive HTML report.
func ExportHTML(report *AnalysisReport) (string, error) {
	if report == nil {
		return "", fmt.Errorf("report cannot be nil")
	}

	opts := DefaultExportOptions(FormatHTML)
	return ExportHTMLWithOptions(report, opts)
}

// ExportHTMLWithOptions generates HTML with custom options.
func ExportHTMLWithOptions(report *AnalysisReport, opts ExportOptions) (string, error) {
	if report == nil {
		return "", fmt.Errorf("report cannot be nil")
	}

	var sb strings.Builder

	// HTML header
	sb.WriteString("<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n")
	sb.WriteString("    <meta charset=\"UTF-8\">\n")
	sb.WriteString("    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n")
	sb.WriteString(fmt.Sprintf("    <title>%s</title>\n", html.EscapeString(report.Title)))
	sb.WriteString("    <style>\n")
	sb.WriteString(getEmbeddedCSS())
	sb.WriteString("    </style>\n")
	sb.WriteString("</head>\n<body>\n")

	// Header
	sb.WriteString("    <header>\n")
	sb.WriteString(fmt.Sprintf("        <h1>%s</h1>\n", html.EscapeString(report.Title)))
	if opts.IncludeMetadata {
		sb.WriteString(fmt.Sprintf("        <p class=\"metadata\">Generated: %s</p>\n",
			report.Timestamp.Format(time.RFC3339)))
		if report.Source != "" {
			sb.WriteString(fmt.Sprintf("        <p class=\"metadata\">Source: <code>%s</code></p>\n",
				html.EscapeString(report.Source)))
		}
	}
	sb.WriteString("    </header>\n\n")

	// Main content
	sb.WriteString("    <main>\n")

	// Table of contents
	sb.WriteString("        <nav class=\"toc\">\n")
	sb.WriteString("            <h2>Table of Contents</h2>\n")
	sb.WriteString("            <ul>\n")
	if opts.IncludeStatistics {
		sb.WriteString("                <li><a href=\"#statistics\">Overview Statistics</a></li>\n")
	}
	if opts.IncludeFrequencies {
		sb.WriteString("                <li><a href=\"#frequencies\">Entity Frequency Analysis</a></li>\n")
	}
	if opts.IncludePatterns {
		sb.WriteString("                <li><a href=\"#patterns\">Relationship Patterns</a></li>\n")
	}
	if opts.IncludeTypedHoles {
		sb.WriteString("                <li><a href=\"#holes\">Typed Holes</a></li>\n")
	}
	if opts.IncludeTripleGraph {
		sb.WriteString("                <li><a href=\"#graph\">Triple Graph</a></li>\n")
	}
	sb.WriteString("            </ul>\n")
	sb.WriteString("        </nav>\n\n")

	// Statistics section
	if opts.IncludeStatistics {
		sb.WriteString(formatHTMLStatistics(report))
	}

	// Entity frequency section
	if opts.IncludeFrequencies && len(report.EntityFrequencies) > 0 {
		sb.WriteString(formatHTMLEntityFrequencies(report, opts.MaxFrequenciesToShow))
	}

	// Relationship patterns section
	if opts.IncludePatterns && len(report.RelationshipPatterns) > 0 {
		sb.WriteString(formatHTMLRelationshipPatterns(report, opts.MaxExamplesPerPattern))
	}

	// Typed holes section
	if opts.IncludeTypedHoles && len(report.TypedHoles) > 0 {
		sb.WriteString(formatHTMLTypedHoles(report))
	}

	// Triple graph section
	if opts.IncludeTripleGraph && report.TripleGraph != nil {
		sb.WriteString(formatHTMLTripleGraph(report))
	}

	sb.WriteString("    </main>\n")

	// Footer
	sb.WriteString("    <footer>\n")
	sb.WriteString("        <p>Generated by Pedantic Raven Analysis Engine</p>\n")
	sb.WriteString("    </footer>\n\n")

	// Inline JavaScript for interactivity
	sb.WriteString("    <script>\n")
	sb.WriteString(getEmbeddedJS())
	sb.WriteString("    </script>\n")

	sb.WriteString("</body>\n</html>\n")

	return sb.String(), nil
}

// getEmbeddedCSS returns the embedded CSS stylesheet.
func getEmbeddedCSS() string {
	return `
        /* Base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
            padding: 20px;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }

        .metadata {
            font-size: 0.9rem;
            opacity: 0.9;
            margin-top: 0.5rem;
        }

        main {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        /* Table of contents */
        .toc {
            background: #f8f9fa;
            padding: 1.5rem;
            border-radius: 6px;
            margin-bottom: 2rem;
            border-left: 4px solid #667eea;
        }

        .toc h2 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: #667eea;
        }

        .toc ul {
            list-style: none;
        }

        .toc li {
            margin: 0.5rem 0;
        }

        .toc a {
            color: #667eea;
            text-decoration: none;
            transition: color 0.2s;
        }

        .toc a:hover {
            color: #764ba2;
            text-decoration: underline;
        }

        /* Sections */
        section {
            margin: 3rem 0;
            scroll-margin-top: 20px;
        }

        h2 {
            font-size: 2rem;
            color: #667eea;
            margin-bottom: 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #e0e0e0;
        }

        h3 {
            font-size: 1.5rem;
            color: #764ba2;
            margin: 2rem 0 1rem;
        }

        h4 {
            font-size: 1.2rem;
            color: #555;
            margin: 1.5rem 0 0.75rem;
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            background: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        th, td {
            padding: 0.75rem 1rem;
            text-align: left;
            border-bottom: 1px solid #e0e0e0;
        }

        th {
            background: #667eea;
            color: white;
            font-weight: 600;
            position: sticky;
            top: 0;
            cursor: pointer;
            user-select: none;
        }

        th:hover {
            background: #5568d3;
        }

        tr:hover {
            background: #f8f9fa;
        }

        /* Entity type badges */
        .entity-type {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .entity-type-person { background: #e3f2fd; color: #1976d2; }
        .entity-type-organization { background: #f3e5f5; color: #7b1fa2; }
        .entity-type-technology { background: #e8f5e9; color: #388e3c; }
        .entity-type-concept { background: #fff3e0; color: #f57c00; }
        .entity-type-place { background: #fce4ec; color: #c2185b; }
        .entity-type-thing { background: #f1f8e9; color: #689f38; }

        /* Priority and complexity badges */
        .priority-high { color: #d32f2f; font-weight: bold; }
        .priority-medium { color: #f57c00; font-weight: bold; }
        .priority-low { color: #388e3c; font-weight: bold; }

        /* Collapsible sections */
        .collapsible {
            cursor: pointer;
            padding: 1rem;
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            margin: 0.5rem 0;
            transition: background 0.2s;
        }

        .collapsible:hover {
            background: #e9ecef;
        }

        .collapsible::before {
            content: '▶ ';
            display: inline-block;
            transition: transform 0.2s;
        }

        .collapsible.active::before {
            transform: rotate(90deg);
        }

        .content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            padding: 0 1rem;
        }

        .content.active {
            max-height: 2000px;
            padding: 1rem;
        }

        /* Code blocks */
        code {
            background: #f4f4f4;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 0.9rem;
        }

        pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 1rem;
            border-radius: 6px;
            overflow-x: auto;
            margin: 1rem 0;
        }

        pre code {
            background: none;
            color: inherit;
            padding: 0;
        }

        /* Footer */
        footer {
            text-align: center;
            padding: 2rem;
            color: #666;
            font-size: 0.9rem;
        }

        /* Print styles */
        @media print {
            body {
                background: white;
                padding: 0;
            }

            header {
                background: #667eea;
                print-color-adjust: exact;
                -webkit-print-color-adjust: exact;
            }

            .toc {
                page-break-after: always;
            }

            section {
                page-break-inside: avoid;
            }

            table {
                page-break-inside: avoid;
            }
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            header h1 {
                font-size: 1.8rem;
            }

            main {
                padding: 1rem;
            }

            table {
                font-size: 0.85rem;
            }

            th, td {
                padding: 0.5rem;
            }
        }
`
}

// getEmbeddedJS returns embedded JavaScript for interactivity.
func getEmbeddedJS() string {
	return `
        // Collapsible sections
        document.addEventListener('DOMContentLoaded', function() {
            const collapsibles = document.querySelectorAll('.collapsible');
            collapsibles.forEach(function(collapsible) {
                collapsible.addEventListener('click', function() {
                    this.classList.toggle('active');
                    const content = this.nextElementSibling;
                    if (content) {
                        content.classList.toggle('active');
                    }
                });
            });

            // Table sorting
            const tables = document.querySelectorAll('table');
            tables.forEach(function(table) {
                const headers = table.querySelectorAll('th');
                headers.forEach(function(header, index) {
                    header.addEventListener('click', function() {
                        sortTable(table, index);
                    });
                });
            });
        });

        function sortTable(table, column) {
            const tbody = table.querySelector('tbody');
            if (!tbody) return;

            const rows = Array.from(tbody.querySelectorAll('tr'));
            const isNumeric = !isNaN(parseFloat(rows[0].cells[column].textContent));

            rows.sort(function(a, b) {
                const aVal = a.cells[column].textContent.trim();
                const bVal = b.cells[column].textContent.trim();

                if (isNumeric) {
                    return parseFloat(bVal) - parseFloat(aVal);
                } else {
                    return aVal.localeCompare(bVal);
                }
            });

            rows.forEach(function(row) {
                tbody.appendChild(row);
            });
        }

        // Smooth scrolling for anchor links
        document.querySelectorAll('a[href^="#"]').forEach(function(anchor) {
            anchor.addEventListener('click', function(e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            });
        });
`
}

// formatHTMLStatistics formats the statistics section as HTML.
func formatHTMLStatistics(report *AnalysisReport) string {
	var sb strings.Builder

	sb.WriteString("        <section id=\"statistics\">\n")
	sb.WriteString("            <h2>Overview Statistics</h2>\n")
	sb.WriteString("            <table>\n")
	sb.WriteString("                <thead>\n")
	sb.WriteString("                    <tr><th>Metric</th><th>Value</th></tr>\n")
	sb.WriteString("                </thead>\n")
	sb.WriteString("                <tbody>\n")
	sb.WriteString(fmt.Sprintf("                    <tr><td><strong>Total Entities</strong></td><td>%d</td></tr>\n",
		report.Stats.TotalEntities))
	sb.WriteString(fmt.Sprintf("                    <tr><td><strong>Total Relationships</strong></td><td>%d</td></tr>\n",
		report.Stats.TotalRelationships))
	sb.WriteString(fmt.Sprintf("                    <tr><td><strong>Total Typed Holes</strong></td><td>%d</td></tr>\n",
		report.Stats.TotalTypedHoles))
	sb.WriteString(fmt.Sprintf("                    <tr><td><strong>Unique Entity Types</strong></td><td>%d</td></tr>\n",
		report.Stats.UniqueEntityTypes))
	sb.WriteString(fmt.Sprintf("                    <tr><td><strong>Unique Patterns</strong></td><td>%d</td></tr>\n",
		report.Stats.UniquePatterns))

	if report.Stats.MostCommonEntity != "" {
		sb.WriteString(fmt.Sprintf("                    <tr><td><strong>Most Common Entity</strong></td><td><code>%s</code> (%d occurrences)</td></tr>\n",
			html.EscapeString(report.Stats.MostCommonEntity), report.Stats.MostCommonEntityCount))
	}

	if report.Stats.StrongestPattern != "" {
		sb.WriteString(fmt.Sprintf("                    <tr><td><strong>Strongest Pattern</strong></td><td>%s (%.2f)</td></tr>\n",
			html.EscapeString(report.Stats.StrongestPattern), report.Stats.StrongestPatternScore))
	}

	if report.Stats.HighestPriorityHole != "" {
		sb.WriteString(fmt.Sprintf("                    <tr><td><strong>Highest Priority Hole</strong></td><td><code>%s</code> (priority %d)</td></tr>\n",
			html.EscapeString(report.Stats.HighestPriorityHole), report.Stats.HighestPriority))
	}

	if report.Stats.TotalTypedHoles > 0 {
		sb.WriteString(fmt.Sprintf("                    <tr><td><strong>Average Hole Complexity</strong></td><td>%.1f</td></tr>\n",
			report.Stats.AvgComplexity))
	}

	sb.WriteString("                </tbody>\n")
	sb.WriteString("            </table>\n")
	sb.WriteString("        </section>\n\n")

	return sb.String()
}

// formatHTMLEntityFrequencies formats entity frequencies as HTML.
func formatHTMLEntityFrequencies(report *AnalysisReport, maxShow int) string {
	var sb strings.Builder

	sb.WriteString("        <section id=\"frequencies\">\n")
	sb.WriteString("            <h2>Entity Frequency Analysis</h2>\n")
	sb.WriteString("            <h3>Top Entities by Frequency</h3>\n")

	frequencies := report.EntityFrequencies
	if len(frequencies) > maxShow {
		frequencies = frequencies[:maxShow]
	}

	sb.WriteString("            <table>\n")
	sb.WriteString("                <thead>\n")
	sb.WriteString("                    <tr><th>Rank</th><th>Entity</th><th>Type</th><th>Count</th><th>Importance</th></tr>\n")
	sb.WriteString("                </thead>\n")
	sb.WriteString("                <tbody>\n")

	for i, ef := range frequencies {
		typeClass := getEntityTypeClass(ef.Type)
		sb.WriteString(fmt.Sprintf("                    <tr><td>%d</td><td><code>%s</code></td><td><span class=\"entity-type %s\">%s</span></td><td>%d</td><td>%d/10</td></tr>\n",
			i+1, html.EscapeString(ef.Text), typeClass, ef.Type.String(), ef.Count, ef.Importance))
	}

	sb.WriteString("                </tbody>\n")
	sb.WriteString("            </table>\n")
	sb.WriteString("        </section>\n\n")

	return sb.String()
}

// formatHTMLRelationshipPatterns formats relationship patterns as HTML.
func formatHTMLRelationshipPatterns(report *AnalysisReport, maxExamples int) string {
	var sb strings.Builder

	sb.WriteString("        <section id=\"patterns\">\n")
	sb.WriteString("            <h2>Relationship Patterns</h2>\n")
	sb.WriteString("            <h3>Discovered Patterns</h3>\n")

	sb.WriteString("            <table>\n")
	sb.WriteString("                <thead>\n")
	sb.WriteString("                    <tr><th>Pattern</th><th>Occurrences</th><th>Strength</th><th>Avg Confidence</th></tr>\n")
	sb.WriteString("                </thead>\n")
	sb.WriteString("                <tbody>\n")

	for _, pattern := range report.RelationshipPatterns {
		patternStr := fmt.Sprintf("%s → %s → %s",
			pattern.SubjectType.String(), pattern.Predicate, pattern.ObjectType.String())
		sb.WriteString(fmt.Sprintf("                    <tr><td>%s</td><td>%d</td><td>%.2f</td><td>%.2f</td></tr>\n",
			html.EscapeString(patternStr), pattern.Occurrences, pattern.Strength, pattern.AvgConfidence))
	}

	sb.WriteString("                </tbody>\n")
	sb.WriteString("            </table>\n")
	sb.WriteString("        </section>\n\n")

	return sb.String()
}

// formatHTMLTypedHoles formats typed holes as HTML.
func formatHTMLTypedHoles(report *AnalysisReport) string {
	var sb strings.Builder

	sb.WriteString("        <section id=\"holes\">\n")
	sb.WriteString("            <h2>Typed Holes</h2>\n")
	sb.WriteString("            <h3>Implementation Priority Queue</h3>\n")

	// Sort by priority
	holes := make([]semantic.EnhancedTypedHole, len(report.TypedHoles))
	copy(holes, report.TypedHoles)
	sort.Slice(holes, func(i, j int) bool {
		if holes[i].Priority != holes[j].Priority {
			return holes[i].Priority > holes[j].Priority
		}
		return holes[i].Complexity < holes[j].Complexity
	})

	sb.WriteString("            <table>\n")
	sb.WriteString("                <thead>\n")
	sb.WriteString("                    <tr><th>Priority</th><th>Type</th><th>Complexity</th><th>Constraint</th><th>Dependencies</th></tr>\n")
	sb.WriteString("                </thead>\n")
	sb.WriteString("                <tbody>\n")

	for _, hole := range holes {
		deps := strings.Join(hole.Dependencies, ", ")
		if deps == "" {
			deps = "none"
		}

		priorityClass := getPriorityClass(hole.Priority)
		sb.WriteString(fmt.Sprintf("                    <tr><td class=\"%s\">%d/10</td><td><code>%s</code></td><td>%d/10</td><td>%s</td><td>%s</td></tr>\n",
			priorityClass, hole.Priority, html.EscapeString(hole.Type), hole.Complexity,
			html.EscapeString(hole.Constraint), html.EscapeString(deps)))
	}

	sb.WriteString("                </tbody>\n")
	sb.WriteString("            </table>\n")
	sb.WriteString("        </section>\n\n")

	return sb.String()
}

// formatHTMLTripleGraph formats the triple graph as HTML table.
func formatHTMLTripleGraph(report *AnalysisReport) string {
	var sb strings.Builder

	sb.WriteString("        <section id=\"graph\">\n")
	sb.WriteString("            <h2>Triple Graph</h2>\n")
	sb.WriteString(fmt.Sprintf("            <p><strong>Nodes:</strong> %d | <strong>Edges:</strong> %d</p>\n",
		report.TripleGraph.NodeCount(), report.TripleGraph.EdgeCount()))

	// Top nodes table
	sb.WriteString("            <h3>Top Nodes by Importance</h3>\n")
	sb.WriteString("            <table>\n")
	sb.WriteString("                <thead>\n")
	sb.WriteString("                    <tr><th>Entity</th><th>Type</th><th>Frequency</th><th>Importance</th></tr>\n")
	sb.WriteString("                </thead>\n")
	sb.WriteString("                <tbody>\n")

	// Get top nodes
	type nodePair struct {
		id         string
		node       *analyze.TripleNode
	}
	var nodes []nodePair
	for id, node := range report.TripleGraph.Nodes {
		nodes = append(nodes, nodePair{id, node})
	}
	sort.Slice(nodes, func(i, j int) bool {
		return nodes[i].node.Importance > nodes[j].node.Importance
	})

	maxNodes := 20
	if len(nodes) > maxNodes {
		nodes = nodes[:maxNodes]
	}

	for _, n := range nodes {
		typeClass := getEntityTypeClass(n.node.Entity.Type)
		sb.WriteString(fmt.Sprintf("                    <tr><td><code>%s</code></td><td><span class=\"entity-type %s\">%s</span></td><td>%d</td><td>%d/10</td></tr>\n",
			html.EscapeString(n.id), typeClass, n.node.Entity.Type.String(), n.node.Frequency, n.node.Importance))
	}

	sb.WriteString("                </tbody>\n")
	sb.WriteString("            </table>\n")
	sb.WriteString("        </section>\n\n")

	return sb.String()
}

// getEntityTypeClass returns the CSS class for an entity type.
func getEntityTypeClass(entityType semantic.EntityType) string {
	switch entityType {
	case semantic.EntityPerson:
		return "entity-type-person"
	case semantic.EntityOrganization:
		return "entity-type-organization"
	case semantic.EntityTechnology:
		return "entity-type-technology"
	case semantic.EntityConcept:
		return "entity-type-concept"
	case semantic.EntityPlace:
		return "entity-type-place"
	case semantic.EntityThing:
		return "entity-type-thing"
	default:
		return ""
	}
}

// getPriorityClass returns the CSS class for a priority level.
func getPriorityClass(priority int) string {
	if priority >= 7 {
		return "priority-high"
	} else if priority >= 4 {
		return "priority-medium"
	}
	return "priority-low"
}
